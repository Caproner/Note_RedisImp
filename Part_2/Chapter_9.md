# 第9章 数据库

对于Redis而言，任何数据的本质都是字符串键名+一个任意对象的值的键值对。

故Redis数据库的本质就是键值对的集合。

## 数据库的实现

在Redis中，数据库为一个字典对象，其存储数据库中的键值对，也叫做键空间：

```c
typedef struct redisDb {
  dict *dict;
  // ...
} redisDb;
```

这个字典中，键是一个字符串对象，值为一个任意对象

当执行一个Redis指令的时候，Redis会首先根据指令中指定的键，在字典中找到对应的位置，然后对值对象进行操作。

### 数据库操作

由于数据库本身就是一个字典，只要能找到键所在的位置操作值就可以实现大多数增删查改了，这里只摘比较特殊的做笔记：

+ Redis的`RANDOMKEY`命令的本质就是从字典里随机拿一个键，其他涉及到全局键空间的操作也是类似这个思路
+ 在读写一个键之后，Redis会更新键的字符串对象的lru
+ 如果有客户端`WATCH`一个键的时候，如果有另一个操作写了这个键，那么这个键会被标记为脏键，从而让`WATCH`的客户端注意到
  + 事实上应该是一个脏键计数器，计算键的写操作次数。然后`WATCH`只是获取当前键的计数器用来之后对比。不过这也是自己猜想，具体需要等到之后讲事务的章节才能知道

### 数据库服务端

对于数据库服务端而言，其本身会存多个Redis数据库，也就是一个数据库数组：

```c
struct redisServer {
  redisDb *db;
  int dbnum;
  // ...
};
```

`dbnum`用来记录服务端的数据库数量。初始化服务端的时候Redis一般会一口气建16个数据库。

客户端使用`SELECT`命令可以切换数据库：

```
redis> SET name "Cap"
OK

redis> GET name
"Cap"

redis> SELECT 2
OK

redis[2]> GET name
(nil)
```

### 数据库客户端

Redis的数据库客户端的本质为一个指向当前所在的服务端数据库的指针：

```c
typedef struct redisClient {
  redisDb *db;
  // ...
}redisClient;
```

也就是说，`SELECT`的本质就是切换这个客户端指针。

## 键的过期时间

Redis有一个重要的功能就是设置键的过期时间，令键在某段时间后自动删除。

其一共有四个命令会涉及到过期时间设置：`EXPIRE`、`PEXPIRE`、`EXPIREAT`、`PEXPIREAT`。但事实上前三个指令的本质都是调用最后一个指令并进行换算，故这里只讨论最后一个指令的实现。

> `PEXPIREAT`的含义是设置某个键在某个时间戳（毫秒级）之后过期

### 过期字典

数据库中除了键空间字典之外，还保存了一个记录过期时间的字典：

```c
typedef struct redisDb {
  dict *dict;
  dict *expires;
  // ...
} redisDb;
```

`expires`这个字典的键是与`dict`这个字典的键是一样的，区别在于值。`expires`的值是一个64位整数，记录对应键的过期时间戳。

> 书里对这个值的类型仅用`long long`进行表示，但显然这里肯定不是一个字符串对象。
>
> 回忆一下之前讲字典的章节可以知道，字典的值是一个union，其除了可以指向一个对象之外还可以是一个64位整数值。虽然书里没有明说不过估计就是用的这个，之后看源码的时候需要留意。

有了过期字典之后，`PEXPIREAT`的实现就很好理解了：直接设置字典的值。

> 有一点需要留意，并不是所有的键都在`expires`中有值的。
>
> 当一个键并不存在过期时间的时候，其也就没有在`expires`中对应的键了。

### 过期删除策略

既然定义了过期字典了，同时也需要定义Redis的过期删除策略。

目前所知道的过期删除策略有三种：

+ 定时删除：对于每个键开一个定时任务用来删键。对内存友好但对CPU不友好
+ 惰性删除：等到有人访问这个键了再来看这个键是否需要过期删除。对CPU友好但对内存不友好（会攒很多过期键）
+ 定期删除：开一个总的定时任务，定期清掉全部或一部分过期键。这个策略的优劣取决于定期时间和删除范围

Redis的核心思想是采用第二种（对CPU不友好是很伤的），同时为了防止过期键堆积而多加了第三种。

#### 惰性删除部分

Redis在执行指令之前都会调用`expireIfNeed`函数，用于检查键是否过期。

如果过期就将键删除并返回空或者报错。

其实就是一个过滤器的功能。

#### 定期删除部分

Redis会定期扫一遍所有的数据库，对于每个数据库而言，随机抽取部分键进行过期时间检查，如果过期就删除。

### AOF、RDB、复制功能对过期键的处理

持久化策略对过期键的处理基本方针都是无视之：

+ 对于RDB文件而言：
  + 生成RDB文件的时候，无视掉已经过期的键
  + 载入RDB文件的时候，分两种情况：
    + 主服务器载入的时候，无视掉已经过期的键
    + 从服务器载入的时候，全部载入（这是基于后续提到的从服务器过期策略）
+ 对于AOF文件而已：
  + 生成AOF文件的时候，对于每个过期键而言都添加一条`DEL`指令
  + 重写AOF文件的时候，无视掉已经过期的键的指令

对于复制功能而言，引入了主从服务器之后，为了保证主从服务器的数据一致性：

+ 从服务器不会进行过期键的检查和删除
+ 主服务器在自动删除过期键的时候，会给从服务器发送一条`DEL`指令令其删除

> 这个操作是有BUG的。
>
> 从上面的操作可以看出，假设某个键过期但没被删除的时候，去从服务器读取是会读取到它的值的。这显然不符合逻辑。
>
> 据说Redis 3.2 之后修复了这个bug，到时候读源码的时候需要注意一下。
>
> 事实上对于过期数据是否有必要保持一致性，这一点值得思考。

## 数据库通知

Redis支持用发布订阅模式，将数据库事件通知给订阅者。

数据库通知有两类：

+ 键空间通知：监听某个键的所有指令
+ 键事件通知：监听某个指令的所有操作，不管是对哪个键

其实现的本质就是，在每个指令执行之后，都会发送一次键空间通知和键事件通知。具体的通知操作事实上就是使用`PUBLISH`指令，详细实现需要到18章之后才能知道。