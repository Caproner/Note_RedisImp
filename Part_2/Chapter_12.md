# 第12章 事件

Redis服务器的本质是一个事件驱动服务器。其每个事件循环会去处理两类事情

+ 文件事件：更具体的说是与文件套接字有关的事件。大部分就是网络I/O事件
+ 时间事件：一些定时任务和周期任务

## 文件事件

Redis服务器的文件事件处理器采用I/O多路复用程序来同时监听所有套接字的读写事件，并将事件分配到对应的处理器中执行。

其构成从上往下为：

+ 套接字：多个被监听的I/O套接字
+ I/O多路复用程序：使用系统自带的I/O多路复用库函数，对所有套接字的读写事件进行监听
+ 文件事件分派器：I/O多路复用程序监听到事件之后，会把事件连同套接字按顺序发给文件事件分派器，由其决定分给哪个处理器。文件事件分派器只会在其事件执行结束之后才会接收下一个事件，也就是串行的
+ 事件处理器：包括命令请求处理器、命令回复处理器、连接应答处理器等

### I/O多路复用程序的实现

Redis封装了常见的多路复用库函数，包括`evport`，`epoll`，`kqueue`，`select`等，针对不同的系统使用不同的库函数封装。其按照`evport, epoll, kqueue, select`的顺序依次判断，直到存在相应的库函数就使用其封装来作为多路复用程序。

### 事件类型

Redis的I/O多路复用程序只监听套接字的两种事件：

+ `AE_READABLE`：当套接字可读的时候会产生这种事件
+ `AE_WRITABLE`：当套接字可写的时候会产生这种事件

当套接字同时可读可写的时候，Redis会先处理可读事件，在处理可写事件

### 事件处理器

其包括如下三种：

+ 连接应答处理器：处理连接应答的`AE_READABLE`请求，具体实现为库函数`accept`
+ 命令请求处理器：处理客户端发送命令产生的`AE_READABLE`事件
+ 命令回复处理器：处理客户端准备好接收命令返回的`AE_WRITABLE`事件

其一次完整的Redis客户端与服务端的事件过程如下：

+ Redis服务器初始化，服务器的监听套接字的`AE_READABLE`事件会绑定在多路复用程序上监听连接请求
+ 当客户端跟服务器建立连接的时候，监听套接字接收到`AE_READABLE`事件，由文件事件分派器转给连接应答处理器处理该事件。
  + 处理器处理这个事件的时候，会创建一个对应的客户端套接字，并将客户端套接字和`AE_READABLE`事件绑到多路复用程序上
+ 之后，当客户端发送一个命令的时候，客户端套接字接收到`AE_READABLE`事件，由文件事件分派器转给命令请求处理器进行处理
  + 处理器在执行完命令之后，会将客户端套接字和`AE_WRITABLE`事件绑定在多路复用程序上
+ 之后，如果客户端准备好接收命令的返回的时候，客户端套接字接收到`AE_WRITABLE`事件，由文件事件分派器转给命令回复处理器进行处理
  + 命令回复处理器会将之前处理好的结果写到套接字中

## 时间事件

时间事件包括两种：

+ 定时事件：在某个时刻执行的一次性事件
+ 周期事件：每隔一段时间就要执行一次的事件

其使用一个链表进行管理，链表的一个节点表示一个事件，主要包括：

+ `id`：事件的唯一id
+ `when`：事件执行的时间戳
+ `timeProc`：时间事件处理器，当事件到达时间的时候调用其指向的函数

这里由时间事件处理器决定其是一个定时事件还是周期事件：

+ 如果其为定时事件，时间事件处理器在其执行完之后删除链表上对应的事件节点
+ 如果其为周期事件，时间事件处理器在其执行完之后会去更新链表上对应的事件节点的`when`属性

Redis每次需要执行时间事件的时候，会去扫一遍时间事件链表，取出到期的最小时间事件执行。

由于目前Redis只有`serverCron`这一个周期事件，故扫链表不会成为性能瓶颈。

### serverCron函数

该函数的主要工作包括：

+ 更新服务器的各类统计信息，例如说时间、内存占用、数据库占用情况等
+ 清理过期键值对
+ 关闭和清理连接失效的客户端
+ 尝试持久化操作
+ 对从服务器定期同步
+ 对集群进行定期同步和连接测试

相当于一个函数包揽了所有Redis需要干的定期任务。

该函数在Redis2.6版本默认一秒运行10次，从Redis2.8开始这个函数的每秒运行次数变为可配置项

## 事件的调度和执行

Redis服务器的主函数伪代码如下：

```
int main() {
	初始化();
	while(服务器是否没被执行关闭()) {
		aeProcessEvents();
	}
	关闭服务器();
}
```

`aeProcessEvents()`伪代码如下：

```
void aeProcessEvents() {
	time_event = 时间事件中的最小时间事件节点();
	remaind_ms = time_event.when - 当前时间();
	if(remain_ms < 0) {
		remain_ms = 0;
	}
	timeval = create_timeval_with_ms(remain_ms);
	
	// 阻塞最长timeval秒，等待I/O多路复用程序监听到事件发生
	aeApiPoll(timeval);
	
	处理所有已产生的文件事件();
	处理所有已产生的时间事件();
}
```

这里为了防止文件事件或时间事件执行时间过长导致其他类型事件饿死，这些事件处理器会将耗时过长的事件分多次运行，或者使用子进程或子线程执行。

但即便如此，时间事件还是会因为文件事件而不能完全准时运行。