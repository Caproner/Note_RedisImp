# 第14章 服务器

本章主要讲解Redis服务器的工作原理，其包括如下三个部分：

+ Redis服务器执行命令的过程
+ Redis服务器执行`serverCron`函数的过程
+ Redis服务器初始化的过程

## 命令执行

假设客户端向服务器发送如下命令：

```
SET key value
```

Redis所执行的操作包括如下内容

### 客户端发送命令请求

客户端将命令转换为传输用格式并发送给服务器：

```
*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n
```

发送数据的同时，服务端中的文件事件处理器会监听到对应客户端套接字的可读事件，并调取对应的命令请求处理器。

接下去的事情均由命令请求处理器完成。

### 读取命令请求

命令请求处理器会将输入数据尾部添加到服务器中对应的客户端结构体的输入缓存`querybuf`中。

之后会将该命令从`querybuf`中取出来，按单词分割之后存入命令参数`argv`中。

> 书里提到这里的处理均由被调起的命令请求处理器完成。但一般来说缓存的数据处理是生产者/消费者模式，命令请求处理器将数据塞入之后下一步应该就只是监听返回和给套接字绑定可写事件，而处理缓存数据应该是其他东西来完成。
>
> 但考虑到Redis是单线程运行，所以应该是有别的方法处理了这个问题。之后记得留意一下源码

### 查找命令实现

下一步，服务器需要根据`argv[0]`参数从命令表（一个`stringObj - redisCommand`的字典）中找到对应的`redisCommand`。

`redisCommand`包含如下成员：

+ `name`：`char *`类型，其为存命令名的字符串，如`SET`
+ `proc`：`redisCommandProc *`类型，指向命令的执行函数
  + 其定义为`typedef void redisCommandProc(redisClient *c);`
+ `arity`：`int`类型，表示命令所需的参数个数。如果为负数则表示至少需求其绝对值个数的参数
  + 例如`set`命令的`arity`为-3，而`get`命令为2
  + 注意，命令名本身也算是一个参数，如`SET key value`的参数个数为3
+ `sflags`：`char *`类型，存储标识值的字符串形式，如`wm`（`w`表示其为写入命令，`m`表示这个命令可能会占用大量内存，需要在执行之前对内存状况做检查）
+ `flags`：`int`类型，存储标识值的二进制形式，方便运算
+ `calls`：`long long`类型，服务器总共执行了多少次这个命令
+ `milliseconds`：`long long`类型，服务器执行该命令花费的总时长

找到之后令客户端结构体的`cmd`指针指向该`redisCommand`

### 执行预备操作

在真正执行指令之前，服务器需要执行一系列预备操作：

+ 检查`cmd`是否指向`NULL`，是的话表示找不到对应命令，给客户端返回错误
+ 使用`arity`检查`argc`是否合法，不合法则返回错误
+ 检查是否通过身份校验，不通过则返回错误
+ 如果服务器打开了`maxmemory`功能，则需要检查服务器内存情况，必要时进行内存回收。如果回收失败则返回错误
+ 如果服务器打开了`stop-writes-on-bgsave-error`功能，并且满足了条件（上一次`BGSAVE`出错，并且现在要执行的是写命令），则拒绝执行命令
+ 如果当前客户端正在订阅，则服务器只会执行客户端发来的关于订阅和取消订阅的命令，其他的一律拒绝
+ 如果服务器正在进行数据载入，那么除非客户端发送的命令的`sflags`中包括`l`选项，否则拒绝执行
+ 如果服务器正在执行Lua脚本并超时进入阻塞，则除非客户端发来`SHUTDOWN nosave`或者`SCRIPT KILL`，否则拒绝执行
+ 如果客户端正在执行事务，则除非客户端发送事务相关命令，否则放进事务队列
+ 如果服务器打开监视器功能，则将命令和参数等信息发送给监视器

这一系列预备操作除了最后两个之外基本都在执行过滤操作

### 调用命令实现函数

这一步很简单，只需要调用`cmd`指向的`redisCommand`结构体中的`proc`指向的函数即可。

函数要求传入`redisClient`指针，也就是当前执行命令的客户端指针。

执行函数会自行将执行结果写入到客户端结构体的输出缓存中，并为客户端套接字关联可写事件

### 执行后续工作

命令实现函数执行完毕之后，还需要再执行如下操作：

+ 如果服务器开启慢查询日志功能，则慢查询日志模块会检查是否需要为刚刚的命令添加一条慢查询日志
+ 更新`redisCommand`的`calls`和`milliseconds`成员
+ 如果服务器开启了AOF，并且该命令为写命令，则将该命令添加到AOF缓冲区
+ 如果有从服务器在复制该服务器，并且该命令为写命令，则将该命令传到从服务器

### 返回结果

命令实现函数会将客户端套接字关联可写事件。当事件被触发时，事件处理器调用命令回复处理器，将客户端缓冲区的命令回复发送给客户端。

客户端收到返回数据之后直接打印即可。

## serverCron

之前提到，Redis唯一的时间事件就是执行将所有定时任务一手包办的`serverCron`函数。该函数每隔100ms会执行一次，处理所有服务器该定时处理的事情。

这些操作大致包括：

+ 更新各种时间和性能数值
+ 管理客户端和数据库资源，包括内存管理和超时关闭
+ 处理关机信号
+ 维护持久化操作

其中具体包括如下：

### 更新服务器时间缓存

服务器结构体中有两个关于时间的成员：

```c
struct redisServer {
  // ...
  time_t unixtime;
  long long mstims;
  // ...
};
```

这两个成员分别保存当前系统的秒级时间戳和毫秒级时间戳。

对于一些时间精确度要求不高的事情而言（如打印日志，更新LRU时钟等），Redis服务器会直接使用这两个变量，而非去读取系统时间。

`serverCron`函数第一件需要做的事情就是更新这两个变量。

### 更新LRU时钟

Redis服务器结构体和每个Redis对象都会有一个LRU时钟，记录其最后一次被访问的时间戳，用于计算空转时间：

```c
struct redisServer {
  // ...
  unsigned lruclock:22;
  // ...
};

// ...

typedef struct redisObject {
  // ...
  unsigned lru:22;
  // ...
} robj;
```

`serverCron`函数每隔10秒会更新一遍这个LRU时钟

### 更新服务器每秒执行命令次数

Redis服务器维护了用于估算服务器每秒执行命令次数的参数：

```c
struct redisServer {
  // ...
  
  // 上一次进行抽样的时间
  long long ops_sec_last_sample_time;
  
  // 上一次抽样时，服务器已执行的命令数量
  long long ops_sec_last_sample_ops;
  
  // 记录抽样结果的环形数组
  // REDIS_OPS_SEC_SAMPLES默认值为16
  long long ops_sec_samples[REDIS_OPS_SEC_SAMPLES];
  
  // 记录当前数组下标，每往数组记录一个值则其+1并%REDIS_OPS_SEC_SAMPLES
  int ops_sec_idx;
  
  // ...
};
```

`serverCron`中的`trackOperationsPerSecond`函数每隔100毫秒执行一次

该函数会根据当前时间和当前服务器已执行命令数量来计算一个新的【每秒执行命令次数值】，并将这个值添加到数组中，并更新`ops_sec_last_sample_time`和`ops_sec_last_sample_ops`。

当Redis需要取服务器每秒执行次数的时候，计算数组`ops_sec_samples`的元素平均值并返回即可。

### 更新内存峰值记录

Redis服务端结构体有一个`size_t`类型的成员`stat_peak_memory`用于记录已使用内存的峰值。

`serverCron`每次执行都会更新这个值

### 处理SIGTERM信号

Redis服务器将`SIGTERM`信号关联至`sigtermHandler`函数，该函数会打印日志并将服务器的关闭标识`shtudown_assp`置为1。

而`serverCron`函数每次运行时都会检查`shutdown_assp`成员，如果其为1则关闭服务器。

### 管理客户端资源

`serverCron`每次运行都会调用`clientCron`函数，该函数会对一定数量（而不是全部）的客户端进行如下检查：

+ 如果客户端和服务端连接超时，则释放该客户端
+ 如果客户端输入缓冲区过长，则释放该输入缓冲区，并重新建一个默认大小的输入缓冲区

### 管理数据库资源

`serverCron`每次运行都会调用`databaseCron`函数，该函数会对一定数量（而不是全部）的数据库进行如下检查：

+ 删除过期键
+ 如有必要，对字典进行收缩操作（满足字典收缩条件时）

### 检查和维护持久化操作

Redis服务端有如下变量用于维护持久化操作：

```c
struct redisServer {
  // ...
  
  // BGSAVE 子进程id
  pid_t rdb_child_pid;
  // BGREWRITEAOF 子进程id
  pid_t aof_child_pid;
  // 延迟执行BGREWRITEAOF的标记
  int aof_rewrite_scheduled;
};
```

`serverCron`函数每次执行的时候，会去检查两个pid：

+ 只要有其中一个pid不为-1，则程序执行一次`wait3`函数，检查进程是否有信号发来
  + 如果有信号到达，说明进程执行完毕，服务器执行后续操作（替换RDB/AOF文件）
  + 否则说明进程未执行完毕，程序不做动作
+ 如果两个pid都为-1，则进行如下三个检查：
  + 检查`aof_rewrite_scheduled`是否为1，是的话将标记置为0并执行`BGREWRITEAOF`
    + 当服务器在执行`BGSAVE`的过程中客户端发来`BGREWRITEAOF`的话，服务器不会执行`BGREWRITEAOF`，而是直接设置延迟标记为1
  + 如果自动保存条件满足，并且没有在执行持久化操作，则执行`BGSAVE`
  + 如果重写条件满足，并且没有在执行持久化操作，则执行`BGREWRITEAOF`

### 清空AOF缓冲区

`serverCron`函数每次运行都会将AOF缓冲区的内容写入AOF文件。

### 关闭部分客户端

`serverCron`函数每次运行都会关闭输出缓冲区超出限制的客户端。

硬性限制和软性限制的处理都在这里进行。

### 增加cronloops计数器的值

Redis服务器有一个整型变量`cronloops`，用于记录`serverCron`的运行次数。

`serverCron`要做的最后一步就是更新这个值。

## 初始化服务器

Redis服务器启动的时候需要进行初始化。其步骤包括如下几个：

### 初始化服务器状态

`initServerConfig()`函数用于初始化服务器状态，这是Redis服务器最开始会运行的函数。

其主要做如下几件事情：

+ 设置服务器的运行ID
+ 设置服务器的默认配置，包括运行频率、配置文件路径、运行架构、端口号、RDB和AOF持久化条件
+ 初始化服务器的LRU时钟
+ 创建命令表

其所作的事情基本都是在设置常量和配置默认值

### 载入配置选项

下一步，Redis服务器会从配置文件或启动命令的参数中载入配置到Redis服务器结构体中。

### 初始化服务器数据结构

这一步Redis会初始化服务器结构体自身的数据结构，包括：

+ clients链表
+ db数组
+ 用于执行Lua脚本的Lua环境
+ 用于保存频道订阅信息的字典和保存模式订阅信息的链表
+ 用于保存慢查询日志的属性

除此之外，Redis还会做如下初始化：

+ 设置进程信号处理器，例如前面提到的SIGTERM信号
+ 创建共享对象：之前提到过Redis会创建一些默认的字符串对象可供重用，包括整数1到10000和一些常见回复，如OK，ERR等。
+ 打开服务器的监听端口，并为监听套接字关联连接应答事件处理器
+ 为`serverCron`函数创建时间事件
+ 如果AOF持久化功能开启，则打开现有AOF文件，如果不存在则创建新的AOF文件
+ 初始化服务器的I/O模块

当这些操作执行完成之后，Redis会打印出如下信息：

```
                _._
           _.-``__ ''-._
      _.-``    `.  `_.  ''-._           Redis 5.0.7 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ ''-._
 (    '      ,       .-`  | `,    )     Running in standalone mode
 |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379
 |    `-._   `._    /     _.-'    |     PID: 62947
  `-._    `-._  `-./  _.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |           http://redis.io
  `-._    `-._`-.__.-'_.-'    _.-'
 |`-._`-._    `-.__.-'    _.-'_.-'|
 |    `-._`-._        _.-'_.-'    |
  `-._    `-._`-.__.-'_.-'    _.-'
      `-._    `-.__.-'    _.-'
          `-._        _.-'
              `-.__.-'

62947:M 05 Apr 2020 23:26:09.011 # Server initialized
```

### 还原数据库状态

根据之前的RDB和AOF情况，服务器会载入AOF文件或RDB文件（AOF优先级较高）

载入完成之后Redis会打印如下信息：

```
62947:M 05 Apr 2020 23:26:09.012 * DB loaded from disk: 0.001 seconds
```

### 执行事件循环

最后，Redis打印出如下信息，并开始执行事件循环：

```
62947:M 05 Apr 2020 23:26:09.012 * Ready to accept connections
```

