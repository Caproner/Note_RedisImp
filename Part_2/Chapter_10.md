# 第10章 RDB持久化

Redis的持久化策略之一就是，将Redis的所有数据结构以二进制文件的形式保存。这种方式称为RDB持久化。

注意，这不是一个数据库层面的操作，而是一个服务器层面的操作。

## RDB持久化操作

### 写入RDB文件

Redis使用`SAVE`和`BGSAVE`两个命令进行RDB文件写入。执行这两个命令的其中一个的时候，Redis会将当前数据库的内容写到一份RDB文件中。

`SAVE`是阻塞的，当Redis执行`SAVE`的时候，直到执行完成之前无法执行其他指令。相对的`BGSAVE`就是异步的。

其实现底层都是调用`rdbSave()`，只不过`SAVE`直接调用，而`BGSAVE`会fork一个新的进程来调用，并保持原进程监听其完成信号。

### 读取RDB文件

Redis没有读取RDB文件的指令。其会在初始化的时候读入RDB文件。

其读取RDB文件的时候会一直阻塞，直到读取完成。

不过如果有AOF文件的话，Redis会去读取AOF文件，而不是RDB文件。

### 命令冲突

当Redis执行`BGSAVE`的时候，Redis可以执行其他指令。但部分指令会产生冲突：

+ `SAVE`：拒绝执行。Redis不可以允许两个`rdbSave()`同时执行，这会产生竞争条件
  + 至于为什么会竞争，得去读一下源码看看
+ `BGSAVE`：拒绝执行。原因同`SAVE`
+ `BGREWRITEAOF`：延迟到`BGSAVE`执行完之后才执行。
  + 该指令用于重写AOF文件。
  + 不允许同时执行的原因仅仅是怕榨干机器资源（都涉及到大规模磁盘写入操作）。

### 自动间隔保存

Redis支持配置`save`选项来让其自动定时保存。

假设有以下配置：

```
save 900 1
save 300 10
save 60 10000
```

其表示，如果满足以下三个条件的其中一个，Redis就会自动执行`BGSAVE`：

+ 服务器在900秒内执行至少1次写操作
+ 服务器在300秒内执行至少10次写操作
+ 服务器在60秒内执行至少10000次写操作

#### 自动间隔保存的实现

`redisServer`结构中存有保存该配置的结构体：

```c
struct redisServer {
  redisDb *db;
  int dbnum;
  
  struct saveparam *saveparams;
  long long dirty;
  time_t lastsave;
  // ...
};

struct saveparam {
  time_t seconds;
  int changes;
};
```

具体参数含义如下：

+ `saveparams`指针指向一个`saveparam`数组，数组中每个元素对应一项设置，包括秒数和修改数。

+ `dirty`保存从上一次RDB持久化开始算起，服务器的写操作次数（也就是脏次数）。

+ `lastsave`保存上一次RDB持久化的时间戳。

Redis会每隔100毫秒扫一遍`saveparams`所指向的数组，逐个计算检查是否符合条件。

## RDB文件结构

> 记住个大概就好，核心思想还是数据的二进制编码，也就是包结构的思想

RDB文件结构大体如下（这里会画个图，后面就不画图了，直接列出来）：

<img src="img/10_1.png" />

+ `REDIS`：就是五个字符：REDIS。用来标记这是一个RDB文件
+ `db_version`：4个字节，表示RDB文件版本号。这里讨论的是006号版本的文件结构
+ `databases`：多个数据库的本体
+ `EOF`：EOF结束符，标记文件结束
+ `check_sum`：校验和，防篡改用

### databases部分

+ `SELECTDB`：1字节，是一个常量，表示一个数据库的开始
+ `db_number`：保存当前数据库的号码
+ `key_value_pairs`：键值对们，也就是数据库的本体

### key_value_pairs部分

+ `TYPE`：表示该键值对的类型，有五种数据结构及其压缩版本（字符串没有压缩版本）一共九种取值
+ `key`：键，必定为字符串对象
+ `value`：值，`TYPE`指定的类型的对象

### RDB文件中的对象

不同对象的存储方式不同，其在RDB的组织方式也不同。

#### 字符串对象

字符串对象分为整数和字符串两种编码（把embstr吃了？）

##### 整数字符串对象

+ `ENCODING`：编码方式，也就是接下去的整数是多少位的
+ `integer`：整数本体

##### 普通字符串对象（无压缩版本）

当字符串长度小于等于20字节的时候采取此编码：

+ `len`：字符串长度
+ `string`：字符串本体

##### 普通字符串对象（压缩版本）

当字符串长度大于20字节的时候采取此编码：

+ `REDIS_RDB_ENC_LZF`：常量，标记这个字符串被压缩了
+ `compressed_len`：压缩后长度
+ `origin_len`：压缩前长度
+ `compressed_string`：压缩字符串本体，采用LZF算法压缩

> 这里有个问题：如何区分这三种字符串对象？
>
> 有一个可能是，所有前缀常量（压缩常量、整数编码常量）均大于20。当Redis读到这个数字的时候就知道其不可能是len。

#### 列表对象

+ `list_length`：列表长度
+ `item`：列表内的字符串对象。有多个

#### 集合对象

+ `set_size`：集合大小
+ `elem`：集合内的字符串对象。有多个

#### 哈希表对象

+ `hash_size`：哈希表大小
+ `key_value`：键值对，也就是两个连起来的字符串对象。有多个

#### 有序集合对象

+ `sorted_set_size`：有序集合大小
+ `member_score`：成员和分值，事实上也是两个连起来的字符串对象（浮点数转成字符串存）。有多个

#### 整数集合编码的集合对象

这种对象会先将其转为字符串对象，再用字符串对象的方法存

#### 压缩列表编码的对象

同样，这种对象会先将其转为字符串对象，再用字符串对象的方法存

### 分析RDB文件

我们可以使用命令`od -c xxx.rdb`来以二进制的形式打开RDB文件：

```
$ od -c dump.rdb
0000000    R   E   D   I   S   0   0   0   9 372  \t   r   e   d   i   s
0000020    -   v   e   r 005   5   .   0   .   7 372  \n   r   e   d   i
0000040    s   -   b   i   t   s 300   @ 372 005   c   t   i   m   e 327
0000060    ׃  **   k   ^ 372  \b   u   s   e   d   -   m   e   m      **
0000100   \b 020  \0 372  \f   a   o   f   -   p   r   e   a   m   b   l
0000120    e 300  \0 377  朙  **  ** 230  \f   Q   5 022
0000134
```

> 我的服务器的RDB文件版本是009，跟上面讲的是对不上的。
>
> 不过思想都是差不多的

