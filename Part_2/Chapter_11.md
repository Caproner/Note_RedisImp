# 第11章 AOF持久化

Redis的另一个持久化策略是，将所有执行过的写指令存到文件中。这就是AOF持久化策略，对应的写入文件也被称为AOF文件。

同样的，这也是一个服务器层面的操作。

## AOF持久化操作

简单地讲就是，每次Redis执行写操作的时候，将指令的副本存入AOF文件中。

假设现在对空白数据库0执行了如下指令：

```
SET msg "hello"
GET msg
SADD fruits "apple" "banana" "cherry"
RPUSH numbers 128 256 512
```

那么写入之后的AOF文件如下：

```
*2\r\n$6\r\nSELECT\r\n$1\r\n0\r\n
*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n
*5\r\n$4\r\nSADD\r\n$6\r\nfruits\r\n$5\r\napple\r\n$6\r\nbanana\r\n$6\r\ncherry\r\n
*5\r\n$5\r\nRPUSH\r\n$7\r\nnumbers\r\n$3\r\n128\r\n$3\r\n256\r\n$3\r\n512\r\n
```

其中，`GET`命令并不是写指令，故不需要写入AOF中。另外还多加了一条`SELECT`指令用于指定数据库。

其格式也很好懂，我们以第二条为例：

```
*3\r\n$3\r\nSET\r\n$3\r\nmsg\r\n$5\r\nhello\r\n
```

将`\r\n`替换为空格之后就是：

```
*3 $3 SET $3 msg $5 hello 
```

不难发现：

+ 第一个带`*`之后的数字表示接下来的字符串个数
+ 每个带`$`之后的数字都表示接下来的字符串的长度

### AOF文件写入实现

每一条指令并不是直接写入文件，而是会写入到aof缓冲区。

这个缓冲区在`redisServer`中：

```c
struct redisServer {
  redisDb *db;
  int dbnum;
  
  struct saveparam *saveparams;
  long long dirty;
  time_t lastsave;
  
  sds aof_buf;
  // ...
};
```

每次Redis执行指令之后都会将要写入的文本尾部添加到`aof_buf`中，然后由Redis事件循环中的`flushAppendOnlyFile()`函数来将缓冲区写入和同步到磁盘文件中。

其写入和同步操作由配置项`appendfsync`决定：

+ 当其为`always`时，每次写入到文件的时候都会同步文件内容
+ 当其为`everysec时，每隔一秒才会进行同步
+ 当其为`no`时，同步操作由操作系统来完成

#### 文件的写入和同步

现在的操作系统在执行`write`的时候，并不会直接将数据写入文件，而是存入内存缓冲区，直到缓冲区空间被填满，或者超出规定时间，才会将缓冲区的数据真正写入到文件中。

但有时候应用程序并不希望这样，它会希望数据能更快刷到文件中。故操作系统提供了`fsync`和`fdatasync`来强制将缓冲区的数据刷到文件中。这就是同步操作。

### AOF文件载入实现

当Redis初始化的时候，如果有AOF文件，则Redis会载入AOF文件。

这里Redis会创建一个不联网的本地伪客户端，由这个伪客户端读取AOF文件的指令并逐条执行，来将数据还原到服务器中。

## AOF重写

AOF的设计原理使得其文件体积会随着时间推移不断增大，甚至超过RDB文件。

故需要提供一个操作进行重写AOF文件，以去掉不必要的指令。

### AOF重写的实现

AOF重写操作并不是真正对旧AOF文件进行重写，而是根据当前数据库的内容重新生成一个AOF文件，并覆盖掉原来的AOF文件。

其大致步骤为：扫描所有的数据库，对于每一个非空数据库而言，先添加`SELECT`指令，并扫描数据库的所有键值对，然后分类讨论：

+ 如果键值对为字符串，则使用`GET`指令获取其值，并依此添加`SET`指令
+ 如果键值对为链表，则使用`LRANGE`指令获取其值，并依此则添加`RPUSH`指令
+ 如果键值对为哈希表，则使用`HGETALL`指令获取其值，并依此则添加`HMSET`指令
+ 如果键值对为集合，则使用`SMEMBERS`指令获取其值，并依此则添加`SADD`指令
+ 如果键值对为有序集合，则使用`ZRANGE`指令获取其值，并依此则添加`ZADD`指令
+ 如果键值对带过期时间，则添加`PEXPIREAT`指令

在实际重写的时候，可能会遇到对象元素过多的情况。故当元素数量超过`REDIS_AOF_REWRITE_ITEMS_PER_CMD`时，会将其拆为多条指令写入到AOF文件中。一般这个值是64。

### AOF后台重写

当我们执行指令`BGREWRITEAOF`的时候，Redis会开启一个新的进程进行AOF重写，这个新的进程拥有Redis服务端数据的备份，此时Redis仍旧可以对客户端指令做出相应。

那这样就会遇到一个问题：当AOF重写过程中，服务端接收到写指令的时候要怎么办？

对此，Redis使用了**AOF重写缓冲区**来解决这个问题。当AOF重写过程中接收到指令的时候，这条指令除了会加到AOF缓冲区之外，还会再加到AOF重写缓冲区。当AOF重写过程完成之后，重写进程给服务端发送信号，服务端便会**阻塞**其他操作，并将AOF重写缓冲区的数据刷入新的AOF文件中，并用新的AOF文件替换掉旧的AOF文件。之后解除阻塞，AOF重写完成。

