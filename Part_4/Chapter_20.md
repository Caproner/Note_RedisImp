# 第20章 Lua脚本

Redis支持客户端传入一段Lua脚本，并在自己的Lua环境中执行。

其会将Lua脚本以其校验和为key保存在Redis中，使得其支持直接用校验和调用脚本。

## Lua环境

Redis服务器会维护一个Redis用的Lua环境，该环境需要保证基础且安全，并保证之后所有的操作都是纯函数操作。

> 也就是说，任何函数都被要求任何时候对于同一种输入只能有同一种输出，不能受到其他外界因素所影响
>
> 故原生随机函数、用户自定义全局变量、随机顺序输出等情况都是不被允许的

其随着Redis服务器初始化而初始化，具体步骤如下：

+ 调用Lua的C_API函数`lua_open`创建一个基础的Lua环境
+ 载入函数库：将一些必要的库（包括基础库、表格库、数学库、字符串库等等）载入Lua环境
  + 不过基础库中的`loadfile`会被删除，这是为了防止用户从外部文件中引入不安全的代码
+ 创建Redis全局表格，存放执行redis命令相关的函数
  + 其中就包括最重要的执行函数`redis.call`和`redis.pcall`
+ 替换Lua原生随机函数
  + Lua原生的随机函数使用系统时间作为随机种子，使得其不满足纯函数条件。
  + 用于替换的随机函数使用0作为随机种子，虽然可以更改种子但种子需要是一个不受外界因素影响的量。
+ 创建排序辅助函数
  + 对于一些对字典的操作会使其输出一部分字典的键/键值对（例如`SMEMBERS`、`HVALS`、`KEYS`等），而由于字典的无序性使得对于内容相同的字典进行同样的操作可能会得到不同的结果。
  + 故当在Lua环境中调用这些命令时，Redis会将其结果自动调用`table.sort`进行排序再返回到Lua环境。
+ 创建`redis.pcall`函数的错误报告辅助函数
+ 保护Lua的全局环境
  + 也就是不允许Lua脚本创建全局变量
  + 但用户的Lua脚本仍旧可以改变已有的全局变量，尽管这是危险的
+ 将Lua环境保存到服务器状态的lua属性里

## Lua环境协作组件

除了Lua环境本身，Redis也需要一些组件。包括：

+ 伪客户端
+ lua_scripts字典

### 伪客户端

Lua环境中执行Redis命令并没有办法直接传给服务器，而是需要用一个本地客户端结构体为中介来执行命令。

其过程为，当Lua调用`redis.call`或`redis.pcall`的时候，除开一些前置和后置操作，其本质就是将命令本身发给伪客户端，由伪客户端让服务器来执行命令，而服务器执行完的结果会发回给伪客户端，再由伪客户端发回去。

### lua_scripts字典

Redis服务器会将`EVAL`和`SCRIPT LOAD`传过来的脚本存储在字典中：

```c
struct redisServer {
  // ...
  dict *lua_scrpits;
  // ...
};
```

其键为脚本的SHA1校验和，值为以字符串形式存储的脚本。

## EVAL的实现

Redis服务器执行`EVAL`函数的过程主要分如下几步：

### 定义脚本函数

首先，Redis服务器需要计算该脚本的校验和，并在Lua脚本中定义一个关于这个脚本的函数：

```lua
function f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91()
  return 'hello world'
end
```

### 存入lua_scripts字典

之后，Redis需要以脚本的校验和为key，将脚本存入lua_scrpits字典中。

### 执行脚本函数

最后就是执行脚本函数了。具体步骤如下：

+ 将`EVAL`命令传入的键名和参数存入`KEYS`数组和`ARGV`数组中。这两个数组是Lua的全局变量
+ 为Lua环境装载超时处理钩子
+ 执行脚本函数
+ 去掉超时处理钩子
+ 将脚本函数所得的结果存到客户端（不是伪客户端，而是发送`EVAL`的客户端）结构体的输出缓冲区，等待返回给客户端
+ 对Lua环境进行垃圾回收

## EVALSHA的实现

`EVALSHA`命令的实现就很简单了。只需要找到lua_scripts字典中有没有对应的SHA1校验和即可：

+ 如果有，表明对应的脚本函数肯定也在Lua环境里，直接到`EVAL`命令的执行脚本函数这一步即可
+ 如果没有，报错

## 脚本管理命令的实现

这里主要讲四个`SCRIPT`命令的实现

### SCRIPT FLUSH

该命令用于清空脚本存储。

其实现就是释放和重建`lua_scrpits`字典，以及关闭和重新初始化一个Lua环境

### SCRIPT EXISTS

该命令用于查找某个校验和是否存在

直接找字典即可

### SCRIPT LOAD

该命令用于存入Lua脚本并返回校验和

其实现就是计算校验和并创建脚本函数和存入字典（也就是完成`EVAL`的前两步）

### SCRIPT KILL

该命令用于在Lua脚本超时的时候杀死脚本

前面讲到，执行脚本函数之前会在Lua环境中载入超时钩子。该钩子的用途是，当Lua脚本函数执行时间超过`lua-time-out`的时候，钩子将会定期在脚本运行的间隙中查看是否有`SCRIPT KILL`命令或者`SHUTDOWN`命令到达服务器。

如果Lua脚本并未做任何写入操作，则当超时钩子检测到服务器接收到`SCRIPT KILL`命令或者`SHUTDOWN`命令的时候，就会执行命令。其中`SCRIPT KILL`是强制终止Lua脚本函数执行，而`SHUTDOWN`则是直接关闭服务器

但是如果Lua脚本已经做过写入操作了，出于数据一致性考虑，超时钩子只会检测和执行`SHUTDOWN nosave`命令。

## 脚本复制

在复制模式下，主服务器会将`EVAL`、`EVALSHA`、`SCRIPT FLUSH`、`SCRIPT LOAD`命令复制给从服务器。

### EVAL、SCRIPT FLUSH、SCRIPT LOAD命令的复制

这三个命令直接传播到从服务器即可

### EVALSHA命令的复制

这个命令不能直接传播。因为可能会出现主服务器上有脚本但从服务器上没有的情况。

> 当主服务器上已经有脚本的时候，如果一台新的从服务器加进来，其在复制结束之后是不会复制到主服务器的脚本字典和脚本函数的。故此时直接传播EVALSHA命令会导致这台从服务器报错

故其需要先判断`EVALSHA`命令是否安全。如果安全再进行传播，否则则改为使用`EVAL`命令进行传播

#### 判断EVALSHA是否安全

Redis服务器结构体维护了一个字典，当且仅当其所有从服务器上都有某个脚本的时候，该字典会记录这个脚本的校验和：

```c
struct redisServer {
  // ...
  dict *repl_scriptcache_dict;
  // ...
};
```

其键为脚本校验和，值为NULL

当主服务器执行了`EVAL`、`SCRIPT FLUSH`、`SCRIPT LOAD`的时候，这个字典会一并进行更新。

此外，当主服务器连接了一个新的从服务器的时候，这个字典会被清空。

于是，判断`EVALSHA`是否安全，只需要看脚本的校验和是否存在于字典中就行了。

