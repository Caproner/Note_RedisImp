# 第19章 事务

Redis可以实现带乐观锁的简单事务功能。其使用`MULTI`，`EXEC`实现事务封装，并使用`WATCH`实现乐观锁。

## 事务的实现

Redis服务器中的`redisClient`对象维护一个事务状态，用于存储该客户端的事务执行状态和事务队列：

```c
typedef struct redisClient {
  // ...
  multiState mstate;
  // ...
} redisClient;

typedef struct multiState {
  // 事务队列
  multiCmd *commands;
  // 队列长度
  int count;
} multiState;

typedef struct multiCmd {
  // 假设命令为SET test 111
  // 则参数数量为3，SET也作为参数之一，跟之前讲数据库的时候一样
  
  // 参数数组
  robj **argv;
  // 参数数量
  int argc;
  // 命令指针
  struct redisCommand *cmd;
} multiCmd;
```

### 事务开始

执行`MULTI`命令标志着事务开始，此时对于的`redisClient`的`flag`会开启`REDIS_MULTI`标记，表示其开始记录事务。

###  命令入队

事务开始之后，接下来从这个客户端接收到的命令如果不是`EXEC`，`DISCARD`，`WATCH`，`MULTI`等事务相关命令，则不执行命令，将命令解析后放入事务状态的事务队列中。

### 执行事务

执行`EXEC`命令标志事务记录完毕，开始执行。

此时Redis服务器不执行其他命令，而是从事务队列中取出命令依次执行，并将命令结果依次放入回复队列。直到全部命令执行完成之后再一并返回，之后再执行其他命令。

## WATCH的实现

Redis实现一种乐观锁功能：通过`WATCH`命令监视某些键，之后直到事务执行的这段时间里，如果这个键被修改过则事务会执行失败。

### 监视的实现

`redisDb`对象会维护一个正在被监视的键的字典：

```c
typedef struct redisDb {
  // ...
  dict *watched_keys;
  // ...
} redisDb;
```

其键为被监视的键值对的键名，值为一个链表，记录所有在监视它的客户端（的`redisClient`指针？）

当收到`WATCH`命令的时候，就会在字典中添加一笔记录。

> 事实上Redis有`UNWATCH`指令，可能原理就是从字典中删除对应记录？

### 监视的触发

当数据库接收到修改命令（如`SET`，`LPUSH`等）时，在执行命令之后会去`watched_keys`查看该键是否被监视。

如果被监视了，则给所有监视它的客户端都打开`REDIS_DIRTY_CAS`的flag，表示其事务已经脏了。

### 判断事务是否执行

在监视机制下，当执行`EXEC`时，redis会在开始执行事务队列的命令之前先判断`REDIS_DIRTY_CAS`是否被打开。

如果被打开则认为事务已经脏了，不执行事务并报错。

## ACID

关系型数据库的事务会保证ACID，即原子性（Atomicity），一致性（Consistency），隔离性（Isolation），耐久性（Durability）。

Redis的事务可以保证前三者，并在某些情况下保证耐久性。

### 原子性

显然，Redis的事务要么全部执行，要么全部不执行。这满足原子性

### 一致性

这里指在事务出错的时候数据库的数据仍能保证数据一致性，不会出现出错的数据。

Redis事务在执行的时候会出现三种错误情况：

+ 入队错误：命令无法解析，入队失败。此时事务会被拒绝执行
  + 在Redis 2.6.5之前则是跳过该错误命令
+ 执行错误：命令在执行的时候报错。此时这条命令不会被执行，但不妨碍后面的命令执行。在全部执行完成之后能够保证正确的指令都被执行
+ 服务器停机：由于Redis依靠持久性文件进行恢复，在事务执行期间不可能会进行持久化操作。故重启之后的Redis要么保持事务没执行的状态，要么保持事务执行完成的状态。

综上，Redis能在出错的时候仍能保证一致性

### 隔离性

Redis执行的时候是单线程串行执行。事务之间可以保证隔离性。

### 耐久性

由于Redis是内存数据库，Redis事务本身不具备保证耐久性的特点。其耐久性依靠持久化操作保持。

当事务执行完成之后进行过持久化操作，则其耐久性得以实现。否则其仍为内存中的数据，只要服务器停机就会丢失。

