# 第8章 对象

前面几章介绍了Redis的各种底层数据结构，而对象则是借助Redis的各种底层数据结构实现面向用户的对象，包括：

+ 字符串对象
+ 列表对象
+ 哈希表对象
+ 集合对象
+ 有序集合对象

## 对象的定义

对象的定义如下：

```c
typedef struct redisObject {
  unsigned type:4;
  unsigned encoding:4;
  void *ptr;
  // ...
} robj;
```

> 变量名后面带冒号定义了该成员的**位域长度**，也就是该成员占用的字节数

本体是`ptr`，指向对象所使用的底层数据结构本体。

另外两个变量分别用于指明对象类型和对象编码

### 对象类型

`type`变量用于存储对象的类型。其一共有5种类型：

+ 字符串对象：`REDIS_STRING`
+ 列表对象：`REDIS_LIST`
+ 哈希对象：`REDIS_HASH`
+ 集合对象：`REDIS_SET`
+ 有序集合对象：`REDIS_ZSET`

Redis中有一个`TYPE`命令用于查询键对应的值的类型，其原理就是获取这个变量

### 对象编码

`encoding`变量用于存储对象的编码，也就是对象采用的底层实现。其一共有8种编码：

+ long类型整数：`REDIS_ENCODING_INT`
+ embstr编码的SDS：`REDIS_ENCODING_EMBSTR`
+ SDS：`REDIS_ENCODING_RAW`
+ 字典：`REDIS_ENCODING_HT`
+ 双端链表：`REDIS_ENCODING_LINKEDLIST`
+ 压缩列表：`REDIS_ENCODING_ZIPLIST`
+ 整数集合：`REDIS_ENCODING_INTSET`
+ 跳跃表和字典：`REDIS_ENCODING_SKIPLIST`

## 字符串对象

字符串对象可以是如下三种编码的一种：

+ long类型整数
+ embstr编码的SDS
+ SDS

### embstr

对于long类型整数而言，`ptr`指针指向一个长整型；对于SDS而言，`ptr`指针指向一个SDS。

这里重点在于embstr的实现。这个结构事实是在SDS的基础上改为，将`redisObject`和`sdshdr`的空间一次性申请。也就是说，这两个结构体在空间上是连续的。

当字符串较短（39字节及以内）时会使用这种编码。其新建和删除只需要申请/释放一次空间，相比于SDS来说效率会高一点。

### 编码使用与转换规则

首先是编码的使用规则：

+ 当字符串为一个long范围内的整数时，使用long类型整数存储
+ 否则，如果字符串长度小于等于39字节，则使用embstr
+ 否则，使用SDS

其次是转换规则：

+ 当在long类型整数编码的情况下，将数据改为不符合条件的字符串，则转为SDS
+ 当在embstr编码的情况下，对数据进行修改，则转为SDS
  + 因为embstr结构是只读的，没有相应的修改程序
+ 以上两种转换都是不可逆的，SDS不会转换成其他类型

### incrby命令

知道了其底层实现和转换规则之后，就可以知道其命令的底层实现了

但其中有一个需要提一下，就是`incrby`命令。这个命令只会在整数编码的时候才能执行，当其编码为embstr或SDS时，会直接报错

但如果使用的是`incrbyfloat`的话，后两者就会去尝试将字符串转换为浮点数

## 列表对象

> 从列表对象开始，任何一个对象如果需要用到字符串（不管是键还是值），其都会指向一个字符串对象。
>
> 也只有字符串对象会被嵌套使用。

列表对象只会有两种编码：小规模时使用的压缩列表，和一般情况下使用的双端链表。

## 哈希对象

哈希对象也只会有两种编码：小规模时使用的压缩列表，和一般情况下使用的字典。

### 压缩列表下的哈希对象存储

在压缩对象底层的情况下，一个键值对会被当做两个相邻的字符串对象来存储。

也就是说，假设这个哈希表是这样的：

```
HMSET character_info:1 name Jack age 22 team flame
```

那么，其在底层就是使用压缩列表的方式进行存储。其列表长度为6，成员从左往右分别是：

```
name Jack age 22 team flame
```

## 集合对象

集合对象只会有两种编码：小规模整数时使用的整数集合，和一般情况下使用的字典。

## 有序集合对象

有序集合只会有两种编码：小规模时使用的压缩列表，和一般情况下使用的zset结构。

### 压缩列表下的有序集合对象存储

跟哈希表类似的，其仍旧是将键值对当做是两个相邻的字符串对象来存储。

并且按照分数从小到大升序排序。

### ZSET结构

一般情况下，有序集合会使用zset结构，其包括一个跳跃表和一个字典：

```c
typedef struct zset {
  zskiplist *zsl;
  dict *dict;
} zset;
```

也就是说，从结果上看，其拥有两个数据结构在维护同一个键值对集合。

但注意其**并没有将数据存两份**，其只是存了两份指针，换句话说就是，有序集合中的对象会同时被跳跃表里的指针和字典里的指针所指向。

存两份结构的原因是：

+ 对于范围性和有序查找操作，字典需要将数据进行重新排序。此时使用跳跃表来操作就会快得多
+ 对于单个元素的读写，跳跃表仍需要$O(\log N)$的时间来操作，此时使用字典就可以加速到$O(1)$

## 类型检查与命令多态

### 类型检查

很多指令都只能作用于某种类型的结构（例如`HMSET`、`LLEN`等），但我们无法保证用户都是准确执行命令的。

故需要在执行前需要进行类型检查。其具体包括：

+ 检查键指向的对象的`type`是否可以执行这个指令
+ 检查键指向的对象的`encoding`是否有对应的底层实现

### 命令多态

事实上上面就已经涉及到命令的多态了：

+ 当同一个命令在不同的编码下有不同的执行方式时，其为基于编码的多态（例如`LLEN`在压缩列表和双端链表下的不同实现）
+ 当同一个命令在不同的类型下有不同的执行方式时，其为基于类型的多态（例如`DEL`命令适用于任何键）

这种多态的实现依靠其底层结构定义的行为函数指针

## 内存回收

Redis有自动的内存回收机制。当一个对象不再被任何其他对象引用时，Redis会自动释放其空间。

为此，`redisObject`带有一个计数器`refcount`，用于计算其当前被引用的数量。

扩充一下`redisObject`的定义如下：

```c
typedef struct redisObject {
  unsigned type:4;
  unsigned encoding:4;
  void *ptr;
  int refcount;
  // ...
} robj;
```

对象被初始化的时候，计数器的值会被初始化为1（对象会被初始化意味着有人创建了它并指向了它，这就是一次初始引用了）。之后计数器会随着被引用数增加或减少。

当计数器的值降为0时，Redis会自动销毁该对象。

> 注意，这并不意味着Redis能够防止内存泄漏。Redis的内存泄漏有很大一部分原因是指向对象的键无法再被程序找到。详见《Redis实战》

## 对象共享

之前说到，一个对象可以被多个指针指向，就像ZSET里的成员一样。

Redis沿用了这个机制，让整数对象成为可共享的对象。

换言之，当某一个指针需要指向一个整数的时候，如果这个整数对象在Redis里存在，则不需要再新建一个对象，直接指向这个整数对象就行了。这样可以节省很多内存。

目前来说，Redis会在初始化的时候创建很多小整数对象（0~9999），当有任何指针需要有一个在这个范围内的整数对象时，其不会创建一个新的对象，而是指向这些Redis预留的共享对象。

### 为什么只有整数可以

当我们要去找相同的对象的时候，肯定是需要作比较才能得出结论的。

对于整数而言，其比较的时间复杂度为$O(1)$。而对于字符串而言时间复杂度就会增大至$O(N)$，如果是更复杂的对象则更甚。

这个时间成本是划不来的，故共享对象只考虑了整数。

## 空转对象

`redisObject`还有一个成员`lru`，用于记录最后一次被命令访问到该对象的时间。

扩充一下`redisObject`的定义如下：

```c
typedef struct redisObject {
  unsigned type:4;
  unsigned encoding:4;
  void *ptr;
  int refcount;
  unsigned lru:22;
  // ...
} robj;
```

这个值可以用来计算对象的**空转时间**，也就是有多久没有被用过。

这个值可以用于内存回收，当服务器打开`maxmemory`选项，并且服务器用于回收内存的算法为`volatile-lru`或`allkeys-lru`时，当Redis所占的内存超过`maxmemory`时，就会根据空转时间释放对象（优先释放空转时间长的）

