# 第2章 简单动态字符串

在Redis中并没有使用C语言传统的字符串结构，而是自己构建了SDS（简单动态字符串）用来实现字符串结构。

除了肯定不会被修改的字符串常量之外，Redis在任何地方一旦需要用到字符串都是使用SDS（任何字符串的键/值）。

## SDS的定义

SDS相比C字符串而言多了两个整型变量，其中一个标记长度（len），一个标记剩余空字节数（free）：

```c
struct sdshdr {
  int len;
  int free;
  char buf[];
};
```

复用C字符串的好处就是可以直接复用C语言自带的字符串API（例如最经常用到的`printf`）

同时，复用C字符串也就意味着其需要沿袭C字符串的【以`\0`表终止】的规则。

故其`len`不包括`\0`，这意味着SDS中的`buf`实际占的字节数为`len+free+1`。

带上`len`和`free`虽然会多用点空间，不过可以避开C字符串的一些性能问题和缺陷

### 与C字符串的区别

+ 直接读`len`字段就可以获取长度，而C字符串做到同样的事情需要O(N)的时间（`strlen()`）
+ 在写字符串的时候通过对`free`字段的判断可以避开缓冲区溢出的问题
+ SDS可以做到不必每次修改字符串都需要重新分配内存
+ 由于SDS依靠`len`记长度而非必须以`\0`作为结束符，故其是二进制安全的（可以存储任意二进制数据而不用担心丢失，C字符串就会有这个问题）
+ 如上所述，SDS可以兼容部分C字符串函数（毕竟其`buf`部分就是C字符串）

### SDS的内存分配策略

得益于`len`和`free`字段，SDS在每次修改的时候可以通过其自定义的内存重分配方法来减少内存重分配率（毕竟1内存重分配这个操作很耗时间）。

书中介绍到的重分配策略分为：空间预分配和惰性空间释放

#### 空间预分配

当修改后的字符串长度超过`len+free`的时候，Redis就不得不给SDS分配更多的空间了。

Redis除了分配跟新字符串等长的空间之外，还会分配多一段空间。其具体策略为：

+ 当长度小于1MB的时候，会额外分配`len`个字节。此时`len`和`free`相等，总字节数为`len+free+1`。
+ 否则，固定分配多1MB的空间（不包含给`\0`的这一个字节）。

总结就是，小范围平方分配，大范围线性分配。

#### 惰性空间释放

当遇到SDS的字符串长度变小的时候，Redis并不会主动减少分配给SDS的空间（即使字符串清空）。

而是等到释放空间的API被调用的时候才会真正去重分配这段内存。