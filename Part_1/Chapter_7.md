# 第7章 压缩列表

当列表和哈希表的规模较小，且单个元素占字节数较少时，Redis底层采用压缩列表的方式存储列表和哈希表

与整数集合一样，其作为一种压缩结构，核心思想为时间换空间。

## 压缩列表的实现

不同于其他结构，压缩列表直接使用一整段连续空间来存储。这种结构有点像网络传输中的包。

> 也可能只是书里没写出来，这很奇怪。
>
> 之后阅读源码的时候需要着重注意一下压缩列表是否有其struct这点

其结构示意图如下所示：

<img src="img/7_1.png" />

其中：

+ `zlbytes`为一个`uint32_t`的变量，占4字节。其记录压缩列表所占的总字节数
+ `zltail`为一个`uint32_t`的变量，占4字节。其记录从列表首地址到最后一个元素的首地址的偏移量
  + 简单地说就是，`&zlbyte + zltail = &entryN`
+ `zllen`为一个`uint16_t`的变量，占2字节。其记录压缩列表的节点数量
  + 注意，当节点数量大于等于65536（也就是`UINT16_MAX`）时，`zllen`无法存储真正的节点数量，其值将会默认为65536，但此时只有遍历整个列表才能知道真正的节点数量
+ `entry`为列表节点，长度不定
+ `zlend`为一个`uint8_t`的常量，占1字节，默认为`0xFF`。其标记列表结束

### 压缩列表的节点

`entry`的结构如下所示：

<img src="img/7_2.png" />

其中：

+ `previous_entry_length`记录前一个节点的字节数，用于进行反向遍历。其有两种模式：
  + 当前一节点的长度小于254字节时，`prevoius_entry_length`占1字节
  + 否则，`prevoius_entry_length`占5字节，其中第一个字节默认设置为`0xFE`（也就是254），剩余四个字节记录前一个节点的字节数
+ `encoding`记录当前节点的编码方式和长度。其有9种模式：
  + 当`encoding`以`00`开头时，其占1字节，表示其存储一个长度小于等于63字节的字符串。此时长度存在剩余6位
  + 当`encoding`以`01`开头时，其占2字节，表示其存储一个长度小于等于16383字节的字符串。此时长度存在剩余14位
  + 当`encoding`以`10`开头时，其占5字节，表示其存储一个长度小于等于4294967295字节的字符串。此时`10`后面的6位置空，剩余4个字节存长度
  + 当`encoding`以`11`开头时，其占1字节，表示其存储一个数字。具体有：
    + 当`encoding`为`11000000`时，表示其存储一个`int16_t`的整数
    + 当`encoding`为`11010000`时，表示其存储一个`int32_t`的整数
    + 当`encoding`为`11100000`时，表示其存储一个`int64_t`的整数
    + 当`encoding`为`11110000`时，表示其存储一个24位带符号整数
    + 当`encoding`为`11111110`时，表示其存储一个8位带符号整数
    + 当`encoding`为`1111xxxx`时，表示其存储一个0~12之间的整数，其值存在`xxxx`这四位中（偏移量为1，也就是当值为0的时候，`xxxx`为`0001`）
+ `content`保存节点的值

### 连锁更新问题

考虑这么一种情况：列表中所有的节点的长度都在250~253之间。这个时候所有列表节点的`previous_entry_length`的长度都为1字节。

现在往这个列表首部插入一个总长度大于等于254新节点。此时：

+ 原先的第一个节点的`previous_entry_length`需要扩充到5字节，用于存放新的【前一个节点的长度】
+ 扩充后的第一个节点的长度增加了4字节，已经大于等于254了，此时第二个节点也要跟着扩充`previous_entry_length`
+ 扩充后第二个节点也大于等于254字节了，于是随后的节点都会重复这个过程

这个就是**连锁更新**，也是压缩列表结构所出现的一个问题。

### 为什么连锁更新是一个问题

由于每次扩充`previous_entry_length`都需要重新分配空间，并将后面的字节全部往后移4位，单次重分配并后移的时间复杂度为$O(N)$。故最坏的情况下，连锁更新会从头连锁到尾，总计会进行n次重分配和后移，总时间复杂度会增至$O(N^2)$

### 为什么不避免连锁更新问题

即使是存在连锁更新问题，Redis也依然使用压缩列表作为小规模列表和哈希表的底层。原因在于触发连锁更新的条件十分苛刻（需要所有节点刚好250~253个字节），再加上每个节点最多只会扩充一次，故均摊的时间复杂度仍旧是$O(N)$。

> 不过据说新版本的Redis已经不使用压缩列表作为小规模列表的底层了，这个到时候读源码的时候看看
>
> 搞不好这一章就这么成为时代的眼泪了